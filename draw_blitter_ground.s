    ORG $80000

draw_blitter_ground_super_wrapper:
    ; Deathbringer seems to run in the 68000's user mode for the most part, including at the point where the ground
    ; is normally drawn. If we try to write to the Blitter registers when in user mode, we'll crash the machine. We
    ; therefore need to temporarily switch to supervisor mode in order to draw the ground using the Blitter.

    movem.l a0-a2/d0-d2,regs_backup      ; backup registers before switching to supervisor mode

    pea draw_blitter_ground              ; xbios call to call draw_blitter_ground subroutine in supervisor mode
    move.w #$26,-(sp)
    trap #14
    addq.l #6,sp
    rts                                  ; return to main (unmodified) body of game code

regs_backup:
    ds.l 6                               ; 6 long words of storage for backup of regs during supervisor mode switch

draw_blitter_ground:
    movem.l regs_backup,a0-a2/d0-d2      ; restore registers following switch to supervisor mode

    ; First, set up all of the blitter registers. For many of the registers, we only need to do this once, and we can
    ; then perform multiple blits.
    ; 
    ; The Blitter works roughly as follows:
    ;
    ; for (y = 0; y < x_count; y++) {
    ;     for (x = 0; x < x_count; x++) {
    ;         transfer word from source_address to destination_address
    ;         source_address += source_x_increment;
    ;         destination_address += dest_x_increment;
    ;     }
    ;     source_address += source_y_increment;
    ;     destination_address += destination_x_increment;
    ; }
    ;
    ; As part of this initial setup, we're setting the following registers:
    ;
    ; source_x_increment 8a20:
    ;   how many bytes to add to the source address after writing each word. We set to 6 because we're drawing one
    ;   bitplane at a time, and the source data contains 3 bitplanes.
    ;
    ; source_y_increment 8a22:
    ;   how many bytes to add to the source address after writing each line. We decrement by 118 as this returns the
    ;   source address to the start of the source data for the next bitplane once a line has been drawn, meaning that
    ;   the source address is in the correct place ready for the next bitplane to be drawn
    ;
    ; endmask1 8a28/endmask2 8a2a/endmask3 8a2c:
    ;   masking for the beginning, middle and end of each line. Leaving all three values at $ffff means that no source
    ;   values get masked out when drawing to the screen. 
    ;
    ; dest_x_increment 8a2e:
    ;   how many bytes to add to the destination address after writing each word. We set this to 8 because we're
    ;   drawing one bitplane at a time on a four bitplane back buffer.
    ;
    ; dest_y_increment 8a30:
    ;   how many bytes to add to the destination address after writing each line
    ;
    ; x_count 8a36:
    ;   how many words to draw on each line

    lea $ffff8a20.w,a3
    move.w #6,(a3)+                      ; source x increment 8a20
    move.w #-118,(a3)                    ; source y increment 8a22
    addq.l #6,a3                         ; skip source address 8a24 - we'll set it later
    move.w #$ffff,(a3)+                  ; endmask1 8a28
    move.w #$ffff,(a3)+                  ; endmask2 8a2a
    move.w #$ffff,(a3)+                  ; endmask3 8a2c
    move.w #8,(a3)+                      ; dest x increment 8a2e
    move.w #-150,(a3)                    ; dest y increment 8a30
    addq.l #6,a3                         ; skip dest address 8a32 - we'll set it later
    move.w #20,(a3)                      ; xcount 8a36 - 20 words is one line in one bitplane
    addq.l #4,a3                         ; skip ycount 8a38 - we'll set it later

    moveq.l #$23,d7                      ; use d7 as counter - we're going to draw 23 lines of ground

draw_ground_line:

    ; Note that this following block of 12 lines is mostly taken from the original game code. The purpose of this code
    ; is to determine two things:
    ;
    ; 1) The source start address in memory that we'll be copying graphics data from for this line
    ;
    ;    This address will be a multiple of 8, as the planar graphics arrangement on the ST arranges pixels in blocks
    ;    of pixels, and each pixel takes up half a byte or 4 bits. The resulting value is placed in the a3 register,
    ;    ready to be dropped into the Blitter destination register 8a32 further down.
    ;
    ; 2) The number of pixels that we'll need to skew the source data to the right before writing it to the
    ;    destination
    ;
    ;    This is where the real magic of the Blitter happens. The CPU has to jump through some long-winded hoops in
    ;    order to perform per-pixel horizontal scrolling as evidenced by the original code running from address cc32
    ;    to cc4e. The Blitter, on the other hand, can perform this task for free through use of the Skew function! The
    ;    resulting Skew value as generated by this code is placed in the d5 register, ready to be dropped into the
    ;    Skew register 8a3d further down.

    move.w    (a2)+,d0
    add.w     (a2)+,d0
    move.w    d0,d5
    not.w     d5
    lsr.w     #4,d0
    move.w    d0,d1
    add.w     d0,d0
    add.w     d1,d0
    add.w     d0,d0
    movea.l   (a0)+,a3
    adda.w    d0,a3
    andi.w    #$f,d5

    ; Now that we know where we need to copy data from, and how many pixels to skew to the right, we need to populate
    ; Blitter registers accordingly and start the blit.
    ;
    ; We perform 
    ; source_x_increment 8a20:
    ;   how many bytes to add to the source address after writing each word. We set to 6 because we're drawing one
    ;   bitplane at a time, and the source data contains 3 bitplanes.
    ;
    ; source_y_increment 8a22:
    ;   how many bytes to add to the source address after writing each line. We decrement by 118 as this returns the
    ;   source address to the start of the source data for the next bitplane once a line has been drawn, meaning that
    ;   the source address is in the correct place ready for the next bitplane to be drawn
 
    move.l a3,$ffff8a24.w      ; source address 8a24
    move.l a1,$ffff8a32.w      ; destination address 8a32
    or.b #$80,d5               ; generate a value for skew 8a3d - fxsr combined with d5 skew value from above
    move.b d5,$ffff8a3d.w      ; skew 8a3d - set skew and activate fxsr

    macro fill_bitplane        ; define macro to set ycount to 1 line and start the blitter
    move.w #1,$ffff8a38.w      ; ycount 8a38 - draw one line
    move.b #$c0,$ffff8a3c.w    ; control 8a3c - start blitter in hog mode
    endm

    move.w #$0203,$ffff8a3a.w  ; hop/op 8a3a - set blitter to copy from source to destination
    fill_bitplane              ; copy into bitplane 1 using source data
    fill_bitplane              ; copy into bitplane 2 using source data
    fill_bitplane              ; copy into bitplane 3 using source data
    move.w #$f,$ffff8a3a.w     ; hop/op 8a38 - set blitter to write all 1's for bitplane 4
    fill_bitplane              ; write all 1's into bitplane 4

    lea 160(a1),a1             ; advance destination address by one line

    dbra d7,draw_ground_line   ; loop around to start drawing the next line
    rts       



