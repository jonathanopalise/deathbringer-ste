    ORG $80000

draw_blitter_ground_super_wrapper:
    move.l a0,a0_backup
    move.l a1,a1_backup
    move.l a2,a2_backup
    move.l d0,d0_backup
    move.l d1,d1_backup
    move.l d2,d2_backup

    pea draw_blitter_ground
    move.w #$26,-(sp)
    trap #14
    addq.l #6,sp
    rts

a0_backup:
    dc.l 0
a1_backup:
    dc.l 0
a2_backup:
    dc.l 0
d0_backup:
    dc.l 0
d1_backup:
    dc.l 0
d2_backup:
    dc.l 0

draw_blitter_ground:
    move.l a0_backup,a0
    move.l a1_backup,a1
    move.l a2_backup,a2
    move.l d0_backup,d0
    move.l d1_backup,d1
    move.l d2_backup,d2

    ; init blitter
    lea $ffff8a20.w,a3
    move.w #6,(a3)+            ; source x increment 8a20
    move.w #-118,(a3)          ; source y increment 8a22
    addq.l #6,a3               ; skip source address 8a24 - we'll set it later
    move.w #-1,(a3)+           ; endmask1 8a28
    move.w #-1,(a3)+           ; endmask2 8a2a
    move.w #-1,(a3)+           ; endmask3 8a2c
    move.w #8,(a3)+            ; dest x increment 8a2e
    move.w #-150,(a3)          ; dest y increment 8a30
    addq.l #6,a3               ; skip dest address 8a32 - we'll set it later
    move.w #20,(a3)            ; xcount 8a36 - 20 words is one line in one bitplane
    addq.l #4,a3               ; skip ycount 8a38 - we'll set it later

    moveq.l #$23,d7            ; draw 23 lines of ground

draw_ground_line:

    ; Note that this following block of 12 lines is mostly taken from the original game code. The purpose of this code
    ; is to determine two things:
    ;
    ; 1) The source start address in memory that we'll be copying graphics data from for this line
    ;
    ;    This address will be a multiple of 8, as the planar graphics arrangement on the ST arranges pixels in blocks
    ;    of pixels, and each pixel takes up half a byte or 4 bits. The resulting value is placed in the a3 register,
    ;    ready to be dropped into the Blitter destination register 8a32 further down.
    ;
    ; 2) The number of pixels that we'll need to skew the source data to the right before writing it to the
    ;    destination
    ;
    ;    This is where the real magic of the Blitter happens. The CPU has to jump through some long-winded hoops in
    ;    order to perform per-pixel horizontal scrolling as evidenced by the original code running from address cc32
    ;    to cc4e. The Blitter, on the other hand, can perform this task for free through use of the Skew function! The
    ;    resulting Skew value as generated by this code is placed in the d5 register, ready to be dropped into the
    ;    Skew register 8a3d further down.

    move.w    (a2)+,d0
    add.w     (a2)+,d0
    move.w    d0,d5
    not.w     d5
    lsr.w     #4,d0
    move.w    d0,d1
    add.w     d0,d0
    add.w     d1,d0
    add.w     d0,d0
    movea.l   (a0)+,a3
    adda.w    d0,a3
    andi.w    #$f,d5

    ; now draw 3 bitplanes from source a4 to destination a1
    ; d5 contains skew value

    move.l a3,$ffff8a24.w      ; source address 8a24
    move.l a1,$ffff8a32.w      ; destination address 8a32
    or.w #$c080,d5             ; generate a value for control 8a3c - hog mode, fxsr + skew from d5

    macro fill_bitplane        ; define macro to set ycount to 1 line and start the blitter
    move.w #1,$ffff8a38.w      ; ycount 8a38 - draw one line
    move.w d5,$ffff8a3c.w      ; control 8a3c - start blitter
    endm

    move.w #$0203,$ffff8a3a.w  ; hop/op 8a3a - set blitter to copy from source to destination
    fill_bitplane              ; copy into bitplane 1 using source data
    fill_bitplane              ; copy into bitplane 2 using source data
    fill_bitplane              ; copy into bitplane 3 using source data
    move.w #$f,$ffff8a3a.w     ; hop/op 8a38 - set blitter to write all 1's for bitplane 4
    fill_bitplane              ; write all 1's into bitplane 4

    lea 160(a1),a1             ; advance destination address by one line

    dbra d7,draw_ground_line   ; loop around to start drawing the next line
    rts       



